<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>五子棋</title>
    <url>/2019/11/30/%E4%BA%94%E5%AD%90%E6%A3%8B/</url>
    <content><![CDATA[<p>大二下学期Java程序设计内容，<br>使用窗体简单实现五子棋小游戏<br><code>代码实现：</code></p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.awt.*;</span><br><span class="line">import java.awt.event.ActionEvent;</span><br><span class="line">import java.awt.event.ActionListener;</span><br><span class="line">import java.awt.event.MouseAdapter;</span><br><span class="line">import java.awt.event.MouseEvent;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.swing.*;</span><br><span class="line">class chess &#123;</span><br><span class="line">	public int X,Y;</span><br><span class="line">	public int flag;</span><br><span class="line">	public chess() &#123;</span><br><span class="line">		X=0;</span><br><span class="line">		Y=0;</span><br><span class="line">		flag=0;</span><br><span class="line">	&#125;</span><br><span class="line">	public chess(int x,int y) &#123;</span><br><span class="line">		X=x;</span><br><span class="line">		Y=y;</span><br><span class="line">		flag=0;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class FiveChess extends JPanel &#123;</span><br><span class="line">	public Graphics g;</span><br><span class="line">	public chess [][]xy=new chess[15][15];</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		FiveChess fc=new FiveChess();</span><br><span class="line">		fc.go();</span><br><span class="line">	&#125;</span><br><span class="line">	public void go() &#123;</span><br><span class="line">		JFrame frame = new JFrame(&quot;五子棋&quot;);</span><br><span class="line">		frame.setLocation(200,150);</span><br><span class="line">		frame.setSize(800,530);</span><br><span class="line">		frame.setDefaultCloseOperation(3);</span><br><span class="line">		JMenuBar menubar=new JMenuBar();</span><br><span class="line">		JMenu menu1=new JMenu(&quot;开始&quot;);</span><br><span class="line">		JMenu menu2=new JMenu(&quot;帮助&quot;);</span><br><span class="line">		JMenuItem bstart=new JMenuItem(&quot;新游戏&quot;);</span><br><span class="line">		JMenuItem op=new JMenuItem(&quot;如何获胜&quot;);</span><br><span class="line">		menu1.add(bstart);</span><br><span class="line">		menu2.add(op);</span><br><span class="line">		menubar.add(menu1);</span><br><span class="line">		menubar.add(menu2);</span><br><span class="line">		frame.setJMenuBar(menubar);</span><br><span class="line">		</span><br><span class="line">		JTextArea text=new JTextArea();</span><br><span class="line">		text.setPreferredSize(new Dimension(200,100));</span><br><span class="line">		text.setEditable(false);</span><br><span class="line">		</span><br><span class="line">		JPanel panel1=new JPanel();</span><br><span class="line">		panel1.setPreferredSize(new Dimension(300,500));</span><br><span class="line">		panel1.setBackground(Color.white);</span><br><span class="line">		JButton bquit=new JButton(&quot;认输&quot;);</span><br><span class="line">		JButton bundo=new JButton(&quot;悔棋&quot;);</span><br><span class="line">		bquit.setPreferredSize(new Dimension(200,70));</span><br><span class="line">		bundo.setPreferredSize(new Dimension(200,70));</span><br><span class="line">		panel1.add(bquit);</span><br><span class="line">		panel1.add(bundo);</span><br><span class="line">		JRadioButton button1=new JRadioButton(&quot;人机对战&quot;);</span><br><span class="line">		JRadioButton button2=new JRadioButton(&quot;玩家对战&quot;);</span><br><span class="line">		button1.setOpaque(false);</span><br><span class="line">		button2.setOpaque(false);</span><br><span class="line">		button1.setPreferredSize(new Dimension(200,70));</span><br><span class="line">		button2.setPreferredSize(new Dimension(200,70));</span><br><span class="line">		ButtonGroup group=new ButtonGroup();</span><br><span class="line">		group.add(button1);</span><br><span class="line">		group.add(button2);</span><br><span class="line">		panel1.add(button1);</span><br><span class="line">		panel1.add(button2);</span><br><span class="line">		</span><br><span class="line">		panel1.add(text);</span><br><span class="line">		</span><br><span class="line">		this.setBackground(Color.orange);</span><br><span class="line">		frame.setLayout(new BorderLayout());</span><br><span class="line">		frame.add(this,BorderLayout.CENTER);</span><br><span class="line">		frame.add(panel1,BorderLayout.EAST);</span><br><span class="line">		frame.setVisible(true);</span><br><span class="line">		frame.setResizable(false);</span><br><span class="line">		g=this.getGraphics();</span><br><span class="line">		</span><br><span class="line">		setChess();</span><br><span class="line">		listener l=new listener();</span><br><span class="line">	    l.setG(g);</span><br><span class="line">	    l.setP(this);</span><br><span class="line">	    l.setChess(xy);</span><br><span class="line">	    l.setText(text);</span><br><span class="line">	    this.addMouseListener(l);</span><br><span class="line">	    bstart.addActionListener(l);</span><br><span class="line">	    bquit.addActionListener(l);</span><br><span class="line">	    op.addActionListener(l);</span><br><span class="line">	    bundo.addActionListener(l);</span><br><span class="line">	    button1.addActionListener(l);</span><br><span class="line">	    button2.addActionListener(l);</span><br><span class="line">	&#125;</span><br><span class="line">	public void setChess() &#123;</span><br><span class="line">		for(int i=0;i&lt;15;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;15;j++)&#123;</span><br><span class="line">                chess ch=new chess((j+1)*30,(i+1)*30);</span><br><span class="line">                xy[i][j]=ch;</span><br><span class="line">            &#125;               </span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public void draw(Graphics ag) &#123;</span><br><span class="line">		Graphics2D g=(Graphics2D)ag;</span><br><span class="line">		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);</span><br><span class="line">		for(int i=0;i&lt;15;i++) &#123;</span><br><span class="line">			for(int j=0;j&lt;15;j++) &#123;</span><br><span class="line">				  g.setColor(Color.black);</span><br><span class="line">				  g.drawLine(30,30+i*30,450,30+i*30);</span><br><span class="line">	              g.drawLine(30+i*30,30,30+i*30,450);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//System.out.println(&quot;黑方首下&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void paint(Graphics g) &#123;</span><br><span class="line">		super.paint(g);</span><br><span class="line">		draw(g);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class listener extends MouseAdapter implements ActionListener&#123;</span><br><span class="line">    int mode;</span><br><span class="line">    int x,y;                  </span><br><span class="line">    Graphics2D g;       </span><br><span class="line">    int chesscount;             //连成一条线的同一颜色棋子数量</span><br><span class="line">    chess [][]xy;       </span><br><span class="line">    int col=2; </span><br><span class="line">    chess chessnew=new chess(); </span><br><span class="line">    JPanel panel;</span><br><span class="line">    JTextArea text;</span><br><span class="line">    public void setText(JTextArea text) &#123;</span><br><span class="line">    	this.text=text;</span><br><span class="line">    &#125;</span><br><span class="line">     public void setG(Graphics g)&#123;</span><br><span class="line">            this.g=(Graphics2D)g;</span><br><span class="line">        &#125; </span><br><span class="line">    public void setP(JPanel panel)&#123;</span><br><span class="line">        this.panel=panel;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setChess(chess [][]xy)&#123;</span><br><span class="line">        this.xy=xy;</span><br><span class="line">    &#125;</span><br><span class="line">    public void actionPerformed(ActionEvent e) &#123;</span><br><span class="line">        String str= e.getActionCommand();</span><br><span class="line">        if(str.equals(&quot;如何获胜&quot;)) &#123;</span><br><span class="line">        	int b;</span><br><span class="line">        	String str1=&quot;&quot;;</span><br><span class="line">        	byte []tom=new byte[2];</span><br><span class="line">        	try &#123;</span><br><span class="line">        		FileInputStream in=new FileInputStream(&quot;帮助.txt&quot;);</span><br><span class="line">        		while((b=in.read(tom,0,2))!=-1) &#123;</span><br><span class="line">        			String s=new String(tom,0,b);</span><br><span class="line">        			str1+=s;</span><br><span class="line">        			//System.out.print(s);</span><br><span class="line">        		&#125;</span><br><span class="line">        		text.setText(str1);</span><br><span class="line">        		in.close();</span><br><span class="line">        	&#125;catch(IOException ee) &#123;</span><br><span class="line">        		text.setText(&quot;没找到帮助文档&quot;);//System.out.println(&quot;没找到帮助文档&quot;);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(str.equals(&quot;新游戏&quot;)) &#123;</span><br><span class="line">        	for(int i=0;i&lt;15;i++)&#123;</span><br><span class="line">                for(int j=0;j&lt;15;j++)&#123;</span><br><span class="line">                    xy[i][j].flag=0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        	col=2;</span><br><span class="line">            panel.paint(g);</span><br><span class="line">        &#125;</span><br><span class="line">        if(str.equals(&quot;认输&quot;))&#123;</span><br><span class="line">            if(col==1)&#123;</span><br><span class="line">            JOptionPane.showMessageDialog(null, &quot;白棋认输,黑棋胜&quot;); </span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">            JOptionPane.showMessageDialog(null, &quot;黑棋认输,白棋胜&quot;);     </span><br><span class="line">            &#125;</span><br><span class="line">            for(int i=0;i&lt;15;i++)&#123;</span><br><span class="line">                for(int j=0;j&lt;15;j++)&#123;</span><br><span class="line">                    xy[i][j].flag=0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            panel.paint(g);</span><br><span class="line">        &#125;</span><br><span class="line">        if(str.equals(&quot;悔棋&quot;)) &#123;</span><br><span class="line">        	if(chessnew.flag==1) &#123;</span><br><span class="line">        		col=1;</span><br><span class="line">        		text.setText(&quot;白方悔棋，请白方在落一子&quot;);//System.out.println(&quot;白方悔棋，请白方在落一子&quot;);</span><br><span class="line">        	&#125;</span><br><span class="line">        	else &#123;</span><br><span class="line">        		col=2;</span><br><span class="line">        		text.setText(&quot;黑方悔棋，请黑方在落一子&quot;);//System.out.println(&quot;黑方悔棋，请黑方在落一子&quot;);</span><br><span class="line">        	&#125;</span><br><span class="line">        	chessnew.flag=0;</span><br><span class="line">        	panel.paint(g);</span><br><span class="line">        	for(int i=0;i&lt;15;i++) &#123;</span><br><span class="line">        		for(int j=0;j&lt;15;j++) &#123;</span><br><span class="line">        			if(xy[i][j].flag!=0) &#123;</span><br><span class="line">        				if(xy[i][j].flag==1) &#123;</span><br><span class="line">        					g.setColor(Color.white);</span><br><span class="line">        					g.fillOval(xy[i][j].X-10, xy[i][j].Y-10,20,20);</span><br><span class="line">        				&#125;</span><br><span class="line">        				else &#123;</span><br><span class="line">        					g.setColor(Color.black);</span><br><span class="line">        					g.fillOval(xy[i][j].X-10, xy[i][j].Y-10,20,20);	</span><br><span class="line">        				&#125;</span><br><span class="line">        			&#125;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(str.equals(&quot;人人对战&quot;))&#123;</span><br><span class="line">            mode=11;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void mouseClicked(MouseEvent e) &#123;</span><br><span class="line">        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);</span><br><span class="line">        x=e.getX();</span><br><span class="line">        y=e.getY();</span><br><span class="line">        for(int i=0;i&lt;15;i++)&#123;</span><br><span class="line">        	for(int j=0;j&lt;15;j++) &#123;</span><br><span class="line">               if(Math.abs(x-xy[i][j].X)&lt;10&amp;&amp;Math.abs(y-xy[i][j].Y)&lt;10) &#123;</span><br><span class="line">                    if(xy[i][j].flag==0) &#123;</span><br><span class="line">                        if(col == 1)&#123;  </span><br><span class="line">                        	g.setColor(Color.white);//椭圆的左上角xy坐标，椭圆的宽度、高度</span><br><span class="line">                            g.fillOval(xy[i][j].X-12, xy[i][j].Y-12,20,20);</span><br><span class="line">                            xy[i][j].flag=1;          </span><br><span class="line">                            chessnew=xy[i][j]; </span><br><span class="line">                            col=2;</span><br><span class="line">                            text.setText(&quot;该黑方下棋&quot;);//System.out.println(&quot;该黑方下棋&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if(col==2)&#123;</span><br><span class="line">                        	</span><br><span class="line">                        	g.setColor(Color.black);</span><br><span class="line">                            g.fillOval(xy[i][j].X-12, xy[i][j].Y-12,20,20);</span><br><span class="line">                            xy[i][j].flag=2;   </span><br><span class="line">                            col=1;</span><br><span class="line">                            text.setText(&quot;该白方下棋&quot;);//System.out.println(&quot;该白方下棋&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        checkChess( xy[i][j]);</span><br><span class="line">                     &#125;   </span><br><span class="line">                    else	 text.setText(&quot;这里不能落子&quot;);//System.out.println(&quot;这里不能落子&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">        		&#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    public void checkChess(chess ch)&#123;</span><br><span class="line">        int count1=1;</span><br><span class="line">        int	count2=1;</span><br><span class="line">        int count3=1;</span><br><span class="line">        int count4=1;</span><br><span class="line">        int x=ch.Y/30-1;</span><br><span class="line">        int y=ch.X/30-1;</span><br><span class="line">        for(int j=y+1;j&lt;15;j++)&#123;              </span><br><span class="line">            if(xy[x][y].flag==xy[x][j].flag)&#123; </span><br><span class="line">                count1++;</span><br><span class="line">        &#125;</span><br><span class="line">            else</span><br><span class="line">                break;                                          </span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=y-1;j&gt;=0;j--)&#123;                         </span><br><span class="line">            if(xy[x][y].flag==xy[x][j].flag)&#123;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(count1&gt;=5)&#123;                                  </span><br><span class="line">            if(xy[x][y].flag==1)</span><br><span class="line">            	JOptionPane.showMessageDialog(null, &quot;白棋胜出&quot;);  </span><br><span class="line">            else</span><br><span class="line">            	JOptionPane.showMessageDialog(null, &quot;黑棋胜出&quot;); </span><br><span class="line">            for(int i=0;i&lt;15;i++)&#123;</span><br><span class="line">                for(int j=0;j&lt;15;j++)&#123;</span><br><span class="line">                    xy[i][j].flag=0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            panel.paint(g);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=x-1;i&gt;=0;i--)&#123;              </span><br><span class="line">            if(xy[x][y].flag==xy[i][y].flag&amp;&amp;xy[x][y].flag!=0)&#123;</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;                                                       </span><br><span class="line">        for(int i=x+1;i&lt;15;i++)&#123;                                </span><br><span class="line">            if(xy[x][y].flag==xy[i][y].flag&amp;&amp;xy[x][y].flag!=0)&#123;</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(count2&gt;=5)&#123;                                  </span><br><span class="line">            if(xy[x][y].flag==1)</span><br><span class="line">            	JOptionPane.showMessageDialog(null, &quot;白棋胜出&quot;); </span><br><span class="line">            else</span><br><span class="line">            	JOptionPane.showMessageDialog(null, &quot;黑棋胜出&quot;); </span><br><span class="line">            for(int i=0;i&lt;15;i++)&#123;</span><br><span class="line">                for(int j=0;j&lt;15;j++)&#123;</span><br><span class="line">                    xy[i][j].flag=0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            panel.paint(g);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=x-1,j=y+1;i&gt;=0&amp;&amp;j&lt;15;i--,j++)&#123;</span><br><span class="line">            if(xy[x][y].flag==xy[i][j].flag&amp;&amp;xy[x][y].flag!=0)&#123;</span><br><span class="line">                count3++;</span><br><span class="line">            &#125;</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=x+1,j=y-1;j&gt;=0&amp;&amp;i&lt;15;j--,i++)&#123;</span><br><span class="line">            if(xy[x][y].flag==xy[i][j].flag&amp;&amp;xy[x][y].flag!=0)&#123;</span><br><span class="line">                count3++;</span><br><span class="line">            &#125;</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line">       if(count3&gt;=5)&#123;</span><br><span class="line">            if(xy[x][y].flag==1)</span><br><span class="line">                JOptionPane.showMessageDialog(null, &quot;白棋胜出&quot;); </span><br><span class="line">            else</span><br><span class="line">                JOptionPane.showMessageDialog(null, &quot;黑棋胜出&quot;);</span><br><span class="line">            for(int i=0;i&lt;15;i++)&#123;</span><br><span class="line">                for(int j=0;j&lt;15;j++)&#123;</span><br><span class="line">                    xy[i][j].flag=0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            panel.paint(g);</span><br><span class="line">        &#125;</span><br><span class="line">       for(int i=x+1,j=y+1;i&lt;15&amp;&amp;j&lt;15;i++,j++)&#123; </span><br><span class="line">           if(xy[x][y].flag==xy[i][j].flag&amp;&amp;xy[x][y].flag!=0)&#123;</span><br><span class="line">               count4++;</span><br><span class="line">           &#125;</span><br><span class="line">           else break;</span><br><span class="line">       &#125;</span><br><span class="line">       for(int i=x-1,j=y-1;j&gt;=0&amp;&amp;i&gt;=0;j--,i--)&#123;</span><br><span class="line">           if(xy[x][y].flag==xy[i][j].flag&amp;&amp;xy[x][y].flag!=0)&#123;</span><br><span class="line">               count4++;</span><br><span class="line">           &#125;</span><br><span class="line">           else break;</span><br><span class="line">       &#125;</span><br><span class="line">       if(count4&gt;=5)&#123;</span><br><span class="line">           if(xy[x][y].flag==1)</span><br><span class="line">               JOptionPane.showMessageDialog(null, &quot;白棋胜出&quot;); </span><br><span class="line">           else</span><br><span class="line">               JOptionPane.showMessageDialog(null, &quot;黑棋胜出&quot;);</span><br><span class="line">           for(int i=0;i&lt;15;i++)&#123;</span><br><span class="line">               for(int j=0;j&lt;15;j++)&#123;</span><br><span class="line">                   xy[i][j].flag=0;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           panel.paint(g);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>五子棋</tag>
      </tags>
  </entry>
  <entry>
    <title>进程经典同步问题</title>
    <url>/2019/11/28/%E8%BF%9B%E7%A8%8B%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="哲学家进餐问题-生产者消费者问题-读者-写者问题-银行家算法"><a href="#哲学家进餐问题-生产者消费者问题-读者-写者问题-银行家算法" class="headerlink" title="哲学家进餐问题 生产者消费者问题 读者-写者问题  银行家算法"></a>哲学家进餐问题 生产者消费者问题 读者-写者问题  银行家算法</h1><h4 id="生产者消费者问题："><a href="#生产者消费者问题：" class="headerlink" title="生产者消费者问题："></a>生产者消费者问题：</h4><p>①生产者—消费者之间的同步关系表现为：一旦缓冲池中所有缓冲区均装满产品时，生产者必须等待消费者提供空缓冲区；一旦缓冲池中所有缓冲区全为空时，消费者必须等待生产者提供满缓冲区。<br> </p>
<a id="more"></a>
<p>②生产者—消费者之间还有互斥关系：由于缓冲池是临界资源，所以任何进程在对缓冲区进行存取操作时都必须和其他进程互斥进行。<br><br>PV操作题目分析的步骤：<br><br>1.关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。<br><br>2.整理思路。根据各进程的操作流程确定PV操作的大致顺序。<br><br>3.设置信号量。设置需要的信号量，并根据题目条件确定信号量的初值。<br><code>code：</code><br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore mutex = 1;  //互斥信号量</span><br><span class="line">semaphore empty = n;  //同步信号量。空闲缓冲区的数量</span><br><span class="line">semaphore full = 0;   //同步信号量。产品的数量，非空缓冲区的数量</span><br><span class="line">producer()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">      生成一个产品;</span><br><span class="line">      P(empty); //消耗一个空闲缓冲区</span><br><span class="line">      P(mutex);</span><br><span class="line">      把产品放入缓冲区;</span><br><span class="line">      V(mutex);</span><br><span class="line">      V(full)   //增加一个产品</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">      P(full);   //消耗一个产品</span><br><span class="line">      P(mutex);</span><br><span class="line">      从缓冲区取出一个产品;</span><br><span class="line">      V(mutex);</span><br><span class="line">      V(empty);  //增加一个空闲缓冲区</span><br><span class="line">      使用产品;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="哲学家进餐问题："><a href="#哲学家进餐问题：" class="headerlink" title="哲学家进餐问题："></a>哲学家进餐问题：</h4><p><code>问题描述：·&lt;br&gt;
5个哲学家围坐在一个圆桌上，每两个哲学家之间都有一只筷子，
哲学家平时进行思考，只有当他们饥饿时，才拿起筷子吃饭。
规定每个哲学家只能先取其左边筷子，然后取其右边筷子，然后才可以吃饭。&lt;br&gt;</code>分析：<code>&lt;br&gt;
每一只筷子都是一个临界资源，设置5个互斥信号量。
Semaphore stcik[5]={1,1,1,1,1}
因为：只有占有左边筷子-&gt;占有右边筷子-&gt;吃饭
所以p(左边筷子)-&gt;p(右边筷子)-&gt;吃饭
&lt;br&gt;</code>实现：`</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">	philosopher(0);//注意不可以用循环，因为此中是4个并列的进程。</span><br><span class="line">	philosopher(1);</span><br><span class="line">	philosopher(2);</span><br><span class="line">	philosopher(3);</span><br><span class="line">	philosopher(4);</span><br><span class="line">&#125;</span><br><span class="line">philosopher(int i)&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		思考；</span><br><span class="line">		p(stick[i]);//取左边筷子</span><br><span class="line">		p(stick[i+1]);//取右边筷子</span><br><span class="line"></span><br><span class="line">		进餐；</span><br><span class="line">		V(stick[i]);</span><br><span class="line">		v(stick[i+1]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>问题：</code><br>    如果5个哲学家同时拿起自己左边的筷子，就会发生死锁。<br></p>
<p><code>防止死锁的方法：</code><br><br>（1）方法一：<br>规定在拿到左侧的筷子后，先检查右面的筷子是否可用。如果不可用，则先放下左侧筷子， 等一段时间再重复整个过程。<br>问题：发生饥饿现象；<br>如果同时拿起左边筷子，则右边的筷子都不可用，则放下，然后再次拿起……则谁都无法就餐<br><br>（2）方法二：<br>最多允许四个哲学家同时进餐,以保证至少有一个哲学家能够进餐,最终总会释<br>放出他所使用过的两支筷子,从而可使更多的哲学家进餐。<br></p>
<p><code>伪码：</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5]=&#123;1，1，1，1，1&#125;;</span><br><span class="line">semaphore room=4;</span><br><span class="line">void philosopher(int i)</span><br><span class="line">&#123;</span><br><span class="line">	while(true)</span><br><span class="line">	&#123;</span><br><span class="line">		think();</span><br><span class="line">		wait(room); //请求进入房间进餐</span><br><span class="line">		wait(chopstick[i]); //请求左手边的筷子</span><br><span class="line">		wait(chopstick[(i+1)%5]); //请求右手边的筷子</span><br><span class="line">		eat();</span><br><span class="line">		signal(chopstick[(i+1)%5]); //释放右手边的筷子</span><br><span class="line">		signal(chopstick[i]); //释放左手边的筷子</span><br><span class="line">		signal(room); //退出房间释放信号量room</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）方法三：将拿左筷子，与拿右筷子当做一个原子操作：（即只有当左右筷子均可以拿到时，才拿筷子。<br><br>（4）方法四：规定奇数号的哲学家先拿起他左边的筷子，然后再去拿他右边的筷子;而偶数号 的哲学家则相反。<br><br><code>伪码：</code><br>semaphore chopstick[5]={1，1，1，1，1};<br>void philosopher(int i)<br>    {<br>        while(true)<br>        {<br>            think();<br>            if(i%2 == 0) //偶数哲学家，先右后左。<br>                {<br>                    P (chopstick[ i + 1 ] mod 5) ;<br>                    P (chopstick[ i]) ;<br>                    eat();<br>                    V (chopstick[ i + 1 ] mod 5) ;<br>                    V (chopstick[ i]) ;<br>                }<br>            Else //奇数哲学家，先左后右。<br>                {<br>                    p (chopstick[ i]) ;<br>                    p (chopstick[ i + 1 ] mod 5) ;<br>                    eat();<br>                    V (chopstick[ i]) ;<br>                    V (chopstick[ i + 1 ] mod 5) ;<br>                }<br>        }<br>    }<br>}</p>
<h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><p><code>读者优先:</code><br><br>互斥信号量wrt，初值是1，代表一个共享文件，解决“读－写”互斥，“写－写”互斥。<br>一个记数器，即整型变量readcount，记录读者数，初值是0。 来一个读者， readcount加1 当readcount ＝1表示是第一个读者， 则需要执行p操作抢占文件；否则表示已有读者在安全的读数据。 走一个读者，readcount减1 当readcount ＝0表示是最后一个读者，则需要v操作释放资源；否则表示还有读者在读数据。<br>readcount 为多个读者共享的变量，是临界资源。用互斥信号量mutex控制, mutex初值是1。<br><code>代码：</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int readcount=0; </span><br><span class="line">semaphore mutex=1, wrt=1 ; </span><br><span class="line"> </span><br><span class="line">读者进程：</span><br><span class="line">        wait (mutex);</span><br><span class="line">	readcount++;	</span><br><span class="line">	if (readcount == 1)</span><br><span class="line">	       wait(wrt);</span><br><span class="line">	signal (mutex);</span><br><span class="line">		…</span><br><span class="line">	   reading is performed</span><br><span class="line">		 …</span><br><span class="line">	wait (mutex);</span><br><span class="line">	readcount--;</span><br><span class="line">	if (readcount == 0)</span><br><span class="line">		signal (wrt);</span><br><span class="line">	signal (mutex);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">写者进程：     </span><br><span class="line">      wait(wrt);</span><br><span class="line">	    …</span><br><span class="line">         writing is performed</span><br><span class="line">	    …</span><br><span class="line">      signal(wrt);</span><br></pre></td></tr></table></figure>
<p><code>写者优先:</code><br></p>
<p>在读者优先的基础上</p>
<p>增加信号量r，初值是1：当至少有一个写进程准备访问数据区时，用于禁止所有的读进程。</p>
<p>增加一个记数器，即整型变量writecount，记录写者数，初值是0。 writecount为多个写者共享的变量，是临界资源。用互斥信号量mutex2控制, mutex2初值是1。</p>
<p>增加mutex3，初值是1：在r上不允许建造长队列，否则写进程将不能跳过这个队列，因此，只允许一个读进程在r上排队，而所有其他读进程在等待r之前，在信号量mutex3上排队。<br><code>代码：</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int readcount=0, writecount=0; </span><br><span class="line">semaphore mutex1=1, mutex2=1, mutex3=1, w=1, r=1 ; </span><br><span class="line"> </span><br><span class="line">读者进程：</span><br><span class="line">P(mutex 3);</span><br><span class="line">   P(r);</span><br><span class="line">      P(mutex 1);</span><br><span class="line">         readcount++;</span><br><span class="line">         if (readcount == 1 ) </span><br><span class="line">            P(w);</span><br><span class="line">      V(mutex 1);</span><br><span class="line">    V(r);</span><br><span class="line">V(mutex 3);</span><br><span class="line">      reading is performed</span><br><span class="line">P(mutex 1);</span><br><span class="line">    readcount --;</span><br><span class="line">    if (readcount == 0 )</span><br><span class="line">             V(w);</span><br><span class="line">V(mutex 1);</span><br><span class="line"> </span><br><span class="line">写者进程：     </span><br><span class="line">P(mutex 2);</span><br><span class="line">    writecount++;</span><br><span class="line">    if (writecount == 1 )</span><br><span class="line">           P(r);</span><br><span class="line">V(mutex 2);</span><br><span class="line">P(w);</span><br><span class="line">    writing is performed</span><br><span class="line">V(w);</span><br><span class="line">P(mutex 2);</span><br><span class="line">    writecount --;</span><br><span class="line">    if (writecount == 0)</span><br><span class="line">           V(r);</span><br><span class="line"></span><br><span class="line">V(mutex 2);</span><br></pre></td></tr></table></figure>
<p><code>读写公平:</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int readcount=0; </span><br><span class="line">semaphore mutex=1, rw=1 w=1; </span><br><span class="line"> </span><br><span class="line">读者进程：</span><br><span class="line">        wait (w);</span><br><span class="line">        wait (mutex);</span><br><span class="line">        if (readcount == 0)</span><br><span class="line">	       wait(rw);</span><br><span class="line">    	readcount++;	</span><br><span class="line">    	signal (mutex);</span><br><span class="line">        signal (w);</span><br><span class="line">		…</span><br><span class="line">    	   reading is performed</span><br><span class="line">		 …</span><br><span class="line">    	wait (mutex);</span><br><span class="line">    	readcount--;</span><br><span class="line">    	if (readcount == 0)</span><br><span class="line">    		signal (rw);</span><br><span class="line">    	signal (mutex);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">写者进程：     </span><br><span class="line">    wait(w);</span><br><span class="line">    wait(rw);</span><br><span class="line">	    …</span><br><span class="line">         writing is performed</span><br><span class="line">	    …</span><br><span class="line">    signal(rw);</span><br><span class="line">    signal(w);</span><br></pre></td></tr></table></figure>
<h4 id="银行家算法："><a href="#银行家算法：" class="headerlink" title="银行家算法："></a>银行家算法：</h4><pre><code>参照该博客学的：&lt;br&gt;
https://blog.csdn.net/qq_40693171/&lt;br&gt;
article/details/84780224</code></pre>]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring介绍</title>
    <url>/2019/11/27/%E6%98%A5%E5%A4%A9spring/</url>
    <content><![CDATA[<p>Spring框架是由于软件开发的复杂性而创建的。<br><br>Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。<br>然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，<br>绝大部分Java应用都可以从Spring中受益。<br></p>
<a id="more"></a>
<p>◆·目的·：解决企业应用开发的复杂性<br><br>◆·功能·：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能<br><br>◆·范围·：任何Java应用<br><br><br><br>Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。</p>
]]></content>
      <categories>
        <category>back-end</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2019/11/26/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>这是我的第一篇博客<br></p>
]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>md</tag>
      </tags>
  </entry>
</search>
